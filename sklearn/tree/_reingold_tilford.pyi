# Authors: William Mill (bill@billmill.org)
# License: BSD 3 clause

import numpy as np
from numpy import longlong, ndarray
from typing import Optional, Union

class DrawTree:
    def __init__(
        self,
        tree: "Tree",
        parent: Optional[DrawTree] = None,
        depth: int = 0,
        number: int = 1,
    ) -> None: ...
    def left(self) -> Union[DrawTree, int]: ...
    def right(self) -> Union[DrawTree, int]: ...
    def lbrother(self) -> Optional[DrawTree]: ...
    def get_lmost_sibling(self) -> Optional[DrawTree]: ...

    lmost_sibling = ...

    def __str__(self): ...
    def __repr__(self): ...
    def max_extents(self) -> ndarray: ...

def buchheim(tree: "Tree") -> DrawTree: ...
def third_walk(tree: DrawTree, n: float) -> None: ...
def first_walk(v: DrawTree, distance: float = 1.0) -> DrawTree: ...
def apportion(v: DrawTree, default_ancestor: DrawTree, distance: float) -> DrawTree: ...
def move_subtree(wl: DrawTree, wr: DrawTree, shift: float) -> None: ...
def execute_shifts(v: DrawTree) -> None: ...
def ancestor(vil: DrawTree, v: DrawTree, default_ancestor: DrawTree) -> DrawTree: ...
def second_walk(v: DrawTree, m: Union[int, float] = 0, depth: int = 0, min: Optional[float] = None) -> float: ...

class Tree:
    def __init__(self, label: str = "", node_id: Union[int, longlong] = ..., *children) -> None: ...
