from numpy import float64, ndarray
from sklearn.gaussian_process.kernels import Kernel
from typing import (
    Dict,
    List,
    Optional,
    Tuple,
    Type,
    Union,
    Mapping,
    Sequence,
    Any,
    Callable,
    Literal,
)
from numpy.typing import NDArray, ArrayLike

# Author: Jan Hendrik Metzen <jhm@informatik.uni-bremen.de>
# License: BSD 3 clause

# Note: this module is strongly inspired by the kernel module of the george
#       package.

from abc import ABCMeta, abstractmethod
from collections import namedtuple
import math
from inspect import signature

import numpy as np
from scipy.special import kv, gamma
from scipy.spatial.distance import pdist, cdist, squareform

from ..metrics.pairwise import pairwise_kernels
from ..base import clone
from ..utils.validation import _num_samples
from ..exceptions import ConvergenceWarning

import warnings

def _check_length_scale(X: ndarray, length_scale: Union[float64, ndarray, float, int]) -> Union[ndarray, float64]: ...

class Hyperparameter(namedtuple("Hyperparameter", ("name", "value_type", "bounds", "n_elements", "fixed"))):

    # A raw namedtuple is very memory efficient as it packs the attributes
    # in a struct to get rid of the __dict__ of attributes in particular it
    # does not copy the string for the keys on each instance.
    # By deriving a namedtuple class just to introduce the __init__ method we
    # would also reintroduce the __dict__ on the instance. By telling the
    # Python interpreter that this subclass uses static __slots__ instead of
    # dynamic attributes. Furthermore we don't need any additional slot in the
    # subclass so we set __slots__ to the empty tuple.
    __slots__ = ...

    def __new__(
        cls: Type[Hyperparameter],
        name: str,
        value_type: str,
        bounds: Union[Tuple[float, float], ndarray, str, Tuple[float, int]],
        n_elements: int = 1,
        fixed: None = None,
    ) -> "Hyperparameter": ...

    # This is mainly a testing utility to check that two hyperparameters
    # are equal.
    def __eq__(self, other): ...

class Kernel(metaclass=ABCMeta):
    def get_params(self, deep: bool = True) -> Mapping: ...
    def set_params(self, **params) -> "Kernel": ...
    def clone_with_theta(self, theta: NDArray) -> Union[Sum, Product]: ...
    @property
    def n_dims(self) -> int: ...
    @property
    def hyperparameters(self) -> List[Hyperparameter]: ...
    @property
    def theta(self) -> NDArray: ...
    @theta.setter
    def theta(self, theta) -> NDArray: ...
    @property
    def bounds(self) -> np.ndarray: ...
    def __add__(self, b: "WhiteKernel") -> "Sum": ...
    def __radd__(self, b): ...
    def __mul__(self, b: Union[Exponentiation, RBF]) -> "Product": ...
    def __rmul__(self, b: Union[int, float]) -> "Product": ...
    def __pow__(self, b: int) -> "Exponentiation": ...
    def __eq__(self, b: str) -> bool: ...
    def __repr__(self): ...
    @abstractmethod
    def __call__(self, X, Y=None, eval_gradient=False): ...
    @abstractmethod
    def diag(self, X: ArrayLike) -> np.ndarray: ...
    @abstractmethod
    def is_stationary(self): ...
    @property
    def requires_vector_input(self) -> bool: ...
    def _check_bounds_params(self) -> None: ...

class NormalizedKernelMixin:
    def diag(self, X: NDArray) -> np.ndarray: ...

class StationaryKernelMixin:
    def is_stationary(self): ...

class GenericKernelMixin:
    @property
    def requires_vector_input(self) -> bool: ...

class CompoundKernel(Kernel):
    def __init__(self, kernels: Sequence[Kernel]) -> None: ...
    def get_params(self, deep: bool = True) -> Mapping: ...
    @property
    def theta(self) -> NDArray: ...
    @theta.setter
    def theta(self, theta) -> NDArray: ...
    @property
    def bounds(self) -> NDArray: ...
    def __call__(
        self,
        X: ArrayLike | Sequence[Any],
        Y: ArrayLike | Sequence[Any] | None = None,
        eval_gradient: bool = False,
    ) -> tuple[np.ndarray, NDArray]: ...
    def __eq__(self, b): ...
    def is_stationary(self): ...
    @property
    def requires_vector_input(self): ...
    def diag(self, X: ArrayLike | Sequence[Any]) -> np.ndarray: ...

class KernelOperator(Kernel):
    def __init__(self, k1: Union[ConstantKernel, Product], k2: Kernel) -> None: ...
    def get_params(self, deep: bool = True) -> Mapping: ...
    @property
    def hyperparameters(self) -> List[Hyperparameter]: ...
    @property
    def theta(self) -> NDArray: ...
    @theta.setter
    def theta(self, theta) -> NDArray: ...
    @property
    def bounds(self) -> np.ndarray: ...
    def __eq__(self, b): ...
    def is_stationary(self): ...
    @property
    def requires_vector_input(self) -> bool: ...

class Sum(KernelOperator):
    def __call__(
        self,
        X: ArrayLike | Sequence[Any],
        Y: ArrayLike | Sequence[Any] | None = None,
        eval_gradient: bool = False,
    ) -> tuple[np.ndarray, np.ndarray]: ...
    def diag(self, X: ArrayLike | Sequence[Any]) -> np.ndarray: ...
    def __repr__(self) -> str: ...

class Product(KernelOperator):
    def __call__(
        self,
        X: ArrayLike | Sequence[Any],
        Y: ArrayLike | Sequence[Any] | None = None,
        eval_gradient: bool = False,
    ) -> tuple[np.ndarray, np.ndarray]: ...
    def diag(self, X: ArrayLike | Sequence[Any]) -> np.ndarray: ...
    def __repr__(self) -> str: ...

class Exponentiation(Kernel):
    def __init__(self, kernel: Kernel, exponent: float) -> None: ...
    def get_params(self, deep: bool = True) -> Mapping: ...
    @property
    def hyperparameters(self) -> List[Hyperparameter]: ...
    @property
    def theta(self) -> NDArray: ...
    @theta.setter
    def theta(self, theta) -> NDArray: ...
    @property
    def bounds(self) -> np.ndarray: ...
    def __eq__(self, b): ...
    def __call__(
        self,
        X: ArrayLike | Sequence[Any],
        Y: ArrayLike | Sequence[Any] | None = None,
        eval_gradient: bool = False,
    ) -> tuple[np.ndarray, np.ndarray]: ...
    def diag(self, X: ArrayLike | Sequence[Any]) -> np.ndarray: ...
    def __repr__(self) -> str: ...
    def is_stationary(self): ...
    @property
    def requires_vector_input(self) -> bool: ...

class ConstantKernel(StationaryKernelMixin, GenericKernelMixin, Kernel):
    def __init__(
        self,
        constant_value: float = 1.0,
        constant_value_bounds: tuple[float, float] | Literal["fixed"] = ...,
    ) -> None: ...
    @property
    def hyperparameter_constant_value(self) -> Hyperparameter: ...
    def __call__(
        self,
        X: ArrayLike | Sequence[Any],
        Y: ArrayLike | Sequence[Any] | None = None,
        eval_gradient: bool = False,
    ) -> tuple[np.ndarray, np.ndarray]: ...
    def diag(self, X: ArrayLike | Sequence[Any]) -> np.ndarray: ...
    def __repr__(self) -> str: ...

class WhiteKernel(StationaryKernelMixin, GenericKernelMixin, Kernel):
    def __init__(
        self,
        noise_level: float = 1.0,
        noise_level_bounds: tuple[float, float] | Literal["fixed"] = ...,
    ) -> None: ...
    @property
    def hyperparameter_noise_level(self) -> Hyperparameter: ...
    def __call__(
        self,
        X: ArrayLike | Sequence[Any],
        Y: ArrayLike | Sequence[Any] | None = None,
        eval_gradient: bool = False,
    ) -> tuple[np.ndarray, np.ndarray]: ...
    def diag(self, X: ArrayLike | Sequence[Any]) -> np.ndarray: ...
    def __repr__(self) -> str: ...

class RBF(StationaryKernelMixin, NormalizedKernelMixin, Kernel):
    def __init__(
        self,
        length_scale: float | NDArray = 1.0,
        length_scale_bounds: tuple[float, float] | Literal["fixed"] = ...,
    ) -> None: ...
    @property
    def anisotropic(self) -> bool: ...
    @property
    def hyperparameter_length_scale(self) -> Hyperparameter: ...
    def __call__(self, X: NDArray, Y: NDArray | None = None, eval_gradient: bool = False) -> tuple[np.ndarray, np.ndarray]: ...
    def __repr__(self) -> str: ...

class Matern(RBF):
    def __init__(
        self,
        length_scale: float | NDArray = 1.0,
        length_scale_bounds: tuple[float, float] | Literal["fixed"] = ...,
        nu: float = 1.5,
    ) -> None: ...
    def __call__(self, X: NDArray, Y: NDArray | None = None, eval_gradient: bool = False) -> tuple[np.ndarray, np.ndarray]: ...
    def __repr__(self) -> str: ...

class RationalQuadratic(StationaryKernelMixin, NormalizedKernelMixin, Kernel):
    def __init__(
        self,
        length_scale: float = 1.0,
        alpha: float = 1.0,
        length_scale_bounds: tuple[float, float] | Literal["fixed"] = ...,
        alpha_bounds: tuple[float, float] | Literal["fixed"] = ...,
    ) -> None: ...
    @property
    def hyperparameter_length_scale(self) -> Hyperparameter: ...
    @property
    def hyperparameter_alpha(self) -> Hyperparameter: ...
    def __call__(self, X: NDArray, Y: NDArray | None = None, eval_gradient: bool = False) -> tuple[np.ndarray, np.ndarray]: ...
    def __repr__(self) -> str: ...

class ExpSineSquared(StationaryKernelMixin, NormalizedKernelMixin, Kernel):
    def __init__(
        self,
        length_scale: float = 1.0,
        periodicity: float = 1.0,
        length_scale_bounds: tuple[float, float] | Literal["fixed"] = ...,
        periodicity_bounds: tuple[float, float] | Literal["fixed"] = ...,
    ) -> None: ...
    @property
    def hyperparameter_length_scale(self) -> Hyperparameter: ...
    @property
    def hyperparameter_periodicity(self) -> Hyperparameter: ...
    def __call__(self, X: NDArray, Y: NDArray | None = None, eval_gradient: bool = False) -> tuple[np.ndarray, np.ndarray]: ...
    def __repr__(self) -> str: ...

class DotProduct(Kernel):
    def __init__(
        self,
        sigma_0: float = 1.0,
        sigma_0_bounds: tuple[float, float] | Literal["fixed"] = ...,
    ) -> None: ...
    @property
    def hyperparameter_sigma_0(self) -> Hyperparameter: ...
    def __call__(self, X: NDArray, Y: NDArray | None = None, eval_gradient: bool = False) -> tuple[np.ndarray, np.ndarray]: ...
    def diag(self, X: NDArray) -> np.ndarray: ...
    def is_stationary(self): ...
    def __repr__(self) -> str: ...

# adapted from scipy/optimize/optimize.py for functions with 2d output
def _approx_fprime(xk, f, epsilon, args=()): ...

class PairwiseKernel(Kernel):
    def __init__(
        self,
        gamma: float = 1.0,
        gamma_bounds: tuple[float, float] | Literal["fixed"] = ...,
        metric: Literal[
            "linear",
            "additive_chi2",
            "chi2",
            "poly",
            "polynomial",
            "rbf",
            "laplacian",
            "sigmoid",
            "cosine",
        ]
        | Callable = "linear",
        pairwise_kernels_kwargs: Mapping | None = None,
    ): ...
    @property
    def hyperparameter_gamma(self): ...
    def __call__(self, X: NDArray, Y: NDArray | None = None, eval_gradient: bool = False) -> tuple[np.ndarray, np.ndarray]: ...
    def diag(self, X: NDArray) -> np.ndarray: ...
    def is_stationary(self): ...
    def __repr__(self): ...
