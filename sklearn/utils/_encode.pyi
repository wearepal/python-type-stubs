from contextlib import suppress
from collections import Counter
from typing import Any, Dict, List, Set, Tuple, Union, NamedTuple

import numpy as np
from . import is_scalar_nan
from numpy import float64, int64, ndarray

def _unique(values: ndarray, *, return_inverse=False, return_counts=False) -> Union[Tuple[ndarray, ndarray], ndarray]: ...
def _unique_np(
    values: ndarray, return_inverse: bool = False, return_counts: bool = False
) -> Union[Tuple[ndarray, ndarray], ndarray]: ...

class MissingValues(NamedTuple):

    nan: bool = ...
    none: bool = ...

    def to_list(self) -> List[Any]: ...

def _extract_missing(values: Set[str]) -> Tuple[Set[str], MissingValues]: ...

class _nandict(dict):
    def __init__(self, mapping: Dict[str, int]) -> None: ...
    def __missing__(self, key): ...

def _map_to_integer(values: ndarray, uniques: ndarray) -> ndarray: ...
def _unique_python(values: ndarray, *, return_inverse, return_counts) -> ndarray: ...
def _encode(values: ndarray, *, uniques, check_unknown=True) -> ndarray: ...
def _check_unknown(
    values: ndarray, known_values: ndarray, return_mask: bool = False
) -> Union[Tuple[List[float64], ndarray], Tuple[List[Any], ndarray], Tuple[List[int64], ndarray],]: ...

class _NaNCounter(Counter):
    def __init__(self, items): ...
    def _generate_items(self, items): ...
    def __missing__(self, key): ...

def _get_counts(values, uniques): ...
